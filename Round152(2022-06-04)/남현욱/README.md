
## 감상

이번 주는 또 묘하게 내가 평소에 많이 풀어본 파트의 문제들 위주로 걸려서 전체적으로 쉽게 풀었다. 갈수록 문제 편식을 하게 되면서 잘 하는 파트와 못 하는 파트간의 간극이 커지고 있는 거 같은데 좀 의식적으로라도 잘 못하는 분야의 문제들 위주로 풀어서 간극을 좁힐 필요가 있다는 생각이 든다.

## Timeline

### ~00:05 A AC

문제를 읽어보니 생각보다 조금 까다로웠는데, 부분합을 잘 쓰면 되겠다는 생각이 들어서 그 풀이를 그대로 구현했고 AC를 받았다.

### ~00:08 B AC

자주 접한 유형의 DP 문제여서 풀이가 바로 생각났고, 그걸 구현해서 AC.

### ~00:13 C AC

C번도 읽어보니 바로 풀이가 생각나서 구현하고 AC를 받았다.

### ~00:19 D AC

D번은 읽고 당장 $O(N^3)$ 아래의 풀이가 생각이 안 났는데, 그래프 구조상 $O(N^3)$이 안 나올 수가 없겠다는 생각이 들었다. 그래서 제한상 비트셋 등을 써서 최적화를 하면 시간 안에 돌지 않을까 싶은 생각이 들었고, 계산해보니 대충 맞는거 같아서 그걸 짜서 AC를 받았다.

### ~00:30 E AC

이런 유형의 constructive 문제는 보통 수 크기가 로그 범위로 줄어들게끔 세팅만 해주면 풀리는 경우가 많아서 가능한 방식을 고민해보다가, $n$ 이상의 $x^2$을 아무거나 하나만 찾으면 $x, y$모두 로그 베이스로 줄어든다는 걸 발견하고 그걸 그대로 구현해서 AC를 받았다. 43개 이하로 항상 가능하다는 증명은 잘 모르겠다.

### ~00:43 F AC

아주 여러번 봤던 유형의 정수론 포함배제 문제. 비슷한 문제를 정말 많이 봤기 때문에 풀이가 문제를 읽고 바로 생각나서 그걸 구현해서 맞았다.

### ~02:00

여유가 많이 남아서, Div2 ABC 문제도 풀고 나머지 시간동안 바로 후기도 썼다.

## 풀이

### Div2A. 공사장 표지판

$ i == 0 \mid i == n - 1 \mid j ==0 \mid j == n -1 \mid i == j \mid i == n - i - j $를 만족하는 모든 위치에 *을 찍어주면 된다.

### Div2B. Candy Sharing Game

문제에서 주어진 조건대로 시뮬레이션을 구현하면 맞을 수 있다. 문제에서 입력 제한이 명확히 주어져 있지 않아 좀 애매한 감이 있다..

### Div2C. 이진 딸기

$ 1,2,3,\dots,15,14\dots,2 $를 주기로 같은 결과가 반복되므로, 해당 주기를 구해놓고 주어진 $n$이 몇번째 값에 해당하는지 찾아서 비트에 따라 V혹은 딸기를 출력해주면 된다.

### Div1A. Bitaro the Brave

결국 어떤 J가 있는 칸에 대해서, (J와 같은 줄에서 J 오른쪽에 있는 I의 개수) * (J와 같은 줄에서 J 아래쪽에 있는 O의 개수) 를 모두 더해준 것이 정답이 된다.
특정 위치의 오른쪽 / 아래쪽에 있는 어떤 문자의 개수를 구하는 건 부분합 개념을 통해 $O(HW)$ 시간에 미리 전처리해둔 후 $O(1)$에 구할 수 있으므로, 전체 문제를 $O(HW)$에 해결할 수 있다.

### Div1B. Pascal's Travels

$DP(x,y)$ 를 $x,y$에서 시작해서 $n,n$에 도달하는 경우의 수 라고 정의하자.

$DP(x,y) = DP(x + a_{x,y}, y) + DP(x, y + a_{x,y})$ 가 성립하므로(물론 base case 및 몇 가지 예외 케이스에 대한 처리는 필요하다) $O(N^2)$ 시간에 문제를 해결할 수 있다.

### Div1C. 불장난

$DP(h, a, b)$를 한명은$(h,a)$, 한명은 $(h,b)$에 있을 때($a < b$) 문제에서 요구하는 경우의 수라고 정의하자.

$DP(h, a, b) = DP(h + 1, a, b) + DP(h + 1, a + 1, b) + DP(h + 1, a, b + 1) + DP(h +1, a + 1, b + 1)$ 이 성립한다. 물론 $a = b$ 인 케이스에는 $0$이 된다.

이 식을 그대로 구현해주면 $O(N^3)$에 문제를 해결할 수 있다.

### Div1D. Facebook

$F_i$ 를 $i$번째 사람의 친구 관계를 나타내는 비트열이라고 하자. $i$번째 사람과 $j$번째 사람이 친구면, $F_i$의 $j$번째 비트는 1이 된다.

이 때 두 사람의 공통 친구의 수는 $F_i & F_j$ 에서 비트가 1인 위치의 개수와 동일하게 된다.

비트 연산을 이용하면 속도가 32배 정도 이상 빨라지는 효과가 있으므로, (N^2 + QN/32)$ 정도 시간 복잡도로 생각할 수 있고 이 시간복잡도면 주어진 문제를 해결하는데 충분하다.

### Div1E. IQ Test

어떤 수 $k$가 주어졌을 때, $k$보다 큰 최소한의 $x^2$을 찾으면, $x$와 $y$를 결정할 수 있다. 그러면 $x$와 $y$가 만들어졌다는 가정하에 $x$와 $y$를 써서 $k$를 만들 수 있으므로 동일한 문제의 반복이 된다.

이 때 이러한 $x$와 $y$는 최소한 $k^{0.5}$ 이하이므로, 수의 크기가 지수적으로 감소함을 알 수 있다.

따라서 어떤 수 $n$을 만드는데 필요한 수의 개수도 대충 $O(logN)$에 비례하기 때문에 그렇게 많지 않을거라는 걸 알 수 있고, 이를 그냥 구현하면 AC가 나온다. 정확한 개수 바운드 계산은 잘 모르겠다.

### Div1F. 최대공약수가 뭔데

임의의 $K$개를 골라서 최대 공약수가 $1$이 되는 경우를 구하는 건 어려우니 반대로 생각해보자. 임의의 $K$개를 고르는 모든 경우의 수에서 최대 공약수가 $1$이 아니게 되는 경우의 수를 빼주어도 답을 구할 수 있다.

최대 공약수가 $1$이 아니게 되는 경우를 생각해보면, 임의의 $K$개 수를 뽑아서 $2$의 배수가 되는 경우, $3$의 배수가 되는 경우, ... , 모든 경우를 구해서 더해주면 원하는 값을 구할 수 있음을 알 수 있다.

이 때, 중복해서 배수를 계산할 수 있는데 ($6$의 배수를 셀 때 $2$의 배수와 $3$의 배수도 한 번씩 더 세게 됨), 뫼비우스 함수를 이용하면 이러한 포함배제 처리를 쉽게 할 수 있다. $f(x)$를 $K$개를 골라서 $x$의 배수를 만들 수 있는 경우의 수 라고 정의하면, $2$이상 $10^6$ 이하의 모든 $x$에 대해 $\mu(x) \cdot f(x)$를 더한 것이 $k$개를 뽑아서 최대공약수가 $1$이 아닌 경우의 수가 된다.

이제 각 $f(x)$를 빠르게 구하는 방법만 구하면 되는데, 주어진 배열에서 $x$의 배수의 개수는 미리 에라토스테네스의 체를 응용해서 $O(NlogN)$ 시간에 구해둘 수 있다. 이 개수를 $cnt_x$라고 하면 $f(x) = C(cnt_x, K)$ 와 동일하고, 뫼비우스 함수 역시 $O(logN)$ 시간에 계산할 수 있으므로 $O(NlogN)$에 주어진 문제를 해결할 수 있다.
