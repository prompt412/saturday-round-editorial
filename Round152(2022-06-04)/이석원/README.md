## 감상

- 골드 100제를 푸니까 3, 4번을 푸는 속도가 빨라졌다. (운도 따랐지만) 이번엔 5솔 시점이 80분이었다. 플래 100제까지 풀다보면 잘하면 6솔을 노릴 수도 있을 거 같다.
- 파이썬이 손에 익으니까 구현이 더 빨라졌고 손가락이 덜 힘들다. 처음엔 파이썬으로 풀기 힘들었는데 결과적으로 좋은 선택이었다.

## 풀이 과정

### 1. Bitaro the Brave

- 각 (i, j)에 대해 cell 오른쪽에 있는 O의 개수와 아래에 있는 I의 개수를 빠르게 구하면 되는 문제였다.
- Prefix sum을 써서 풀긴 했는데 실버에서 나올 자료구조가 아니라는 생각을 했다.
- 라운드가 끝나고 다른 풀이(https://www.acmicpc.net/source/31359137) 를 찾아보니 맨 아래 오른쪽 cell부터 역순으로 올라오면서 count를 하면 prefix sum 없이 풀 수 있었다.

### 2. Pascal's Travels

- 좌상단 cell에서 우하단 cell까지 가는 경로의 수를 묻는 전형적인 DP 문제였다.
- 처음 떠오른 풀이는 $ DP(i, j) = \sum_{k < i \:\text{and}\: board[k][j] = (i - k)} DP(k, j) + \sum_{k < j} \:\text{and}\: board[i][k] = (j - k)} DP(i, k) $ 였다.
- $ O(N^3) $ 으로 풀려서 그냥 빠르게 코딩하고 넘어갔다.
- 끝나고 현욱님 설명을 들으면서 $ DP(i, j) = DP(i, j + board[i][j]) + DP(i + board[i][j], j) $ 로 모델링하면 $ O(N^2) $ 에 풀린다는 걸 알게 됐다.

### 3. 불장난

- DP문제 같아서 온갖 생각을 다 했지만 못 풀고 있었다.
- 그러다 우연히 DP parameter에 기웅이와 민수의 위치를 각각 넣어주는 게 어떨까 하는 생각이 들었다.
- 그러면 관계식은 $ DP(h, a, b) = DP(h - 1, a, b) - DP(h - 1, a - 1, b) - DP(h - 1, a, b - 1) - DP(h -1, a - 1, b - 1) $ 이 되고 $ O(N^3) $ 에 풀린다.
- DP는 많이 풀어보는 게 장땡인가 싶었다.

### 4. Facebook

- 주어진 예시를 그려보니 행렬곱이라는 걸 알 수 있었다.
  - 만일 k다리 건너서 아는 친구를 찾는 문제라면 현욱님이 얘기했던 linear recurrence 였을 거다.
- 처음에 무지성으로 행렬곱을 구현했는데 TLE가 나왔고 몇 분 지난 뒤에 $ O(N^3) $ 이 1초만에 안 풀린다는 걸 깨달았다.
- Strassen algorithm을 써야 하나 잠시 고민했지만 그래도 1초로는 부족했다.
- `bitset`을 쓰면 $ 2000^3 / 64 = 1.25억 $ 이 나와서 일단 구현해봤는데 다행히 968ms로 통과했다.
  - [R149](https://github.com/prompt412/saturday-round-editorial/blob/main/Round149(2022-05-14)/%EC%9D%B4%EC%84%9D%EC%9B%90/review.md#4-%EC%97%B0%EC%82%B0-%EC%B5%9C%EB%8C%80%EB%A1%9C)에서도 $ O(1.3억) $ 풀이로 1초 제한을 통과한 적이 있다.
- $ row_{Q_{i, a}} \cdot col_{Q_{i, b}} for 1 \leq i \leq Q $ 로 풀면 더 빨랐을 거다.

### 5. IQ Test

- 예시로 1000을 $ x^2 - y $로 분해해봤더니 아래와 같이 나왔다.
  - $ 1000 = 32^2 - 24 = 33^2 - 89 = 34^2 - 156 = 35^2 - 225 $
- $x$가 커질 수록 $y$가 급격히 증가하길래 가장 작은 $x$를 찾는 게 답이라 생각했다.
- 증명은 건너 뛰고 일단 DFS랑 set을 써서 구현해서 AC를 받았다.
- 지금 생각해봐도 $x, y \leq O(\sqrt{n})$ 이라서 빠르게 감소한다 정도까지만 떠오른다.
  - 43이 lower bound이긴 한 걸까?

### 6. 최대공약수가 뭔데

- 접근법을 떠올릴 수가 없었고 컨테스트가 끝나기 직전에 포기하고 해설을 찾아봤다.
  - 토요라운드 직후에 풀이를 찾아보는 게 가장 기억에 잘 남는 거 같다.
- 포함배제의 원리로 문제를 모델링할 수가 있다.
  - $f(x)$를 최대공약수가 $x$의 배수가 되도록 $K$개의 수를 고르는 방법이라고 해보자.
  - 이때 $1 \leq x \leq 1000000$인 모든 $x$에 대해, $x$의 소인수분해에서 지수가 2 이상인 경우가 있으면 해당 $x$는 무시하고, 나머지 경우 중 소인수가 짝수 개면 더해주고 홀수 개면 빼주면 된다.
  - $f(1) - (f(2) + f(3) + \cdots) + (f(2 \cdot 3) + f(2 \cdot 5) + \cdots + f(3 \cdot 5) + \cdots) - \cdots $
- 이때 앞의 $\pm$을 결정하는 함수가 [뫼비우스 함수](https://ohgym.tistory.com/19) $\mu(x)$ 이다.
- 덕분에 좋은 알고리즘 하나를 배울 수 있었다.
