
## 감상

A번을 읽고 나서 쉬운 풀이가 잘 생각이 안나서 약간 당황했다. 당황해서 B번을 봤는데 B번도 잘 모르겠고, 그래서 C번을 봤는데 C번도 잘 모르겠어서 약간 멘붕.

다시 A번으로 돌아와서 그냥 되게 복잡해보이는 DP를 짜고 맞았는데 다른 사람들은 그리디로 푼 거 같은데 그리디는 잘 모르겠다. 저거 그리디가 실버4는 아닌 것 같은데..? 싶은 생각.

B를 푼 다음에 C를 보니 제한이 $ 2^128 $ 인 점에서 이미 풀기가 싫어져서 건너뛰고 D를 먼저 풀었다. D는 많이 풀어본 유형의 DP라서 비교적 쉽게 풀었고, E를 읽은 다음 E를 풀까 C를 풀까 고민하다 C를 먼저 풀었다. 다시 돌아와서 풀어보니 풀만했다. 그리고 E,F를 순서대로 풀고 마무리. 오늘따라 좀 코딩에 잔실수가 많았던 점이 아쉽다. 정확도를 좀 더 신경써야한다는 생각이 들었다.

## 풀이

### A. Generalized German Quotation

dp(l, r) = l..r 부분 구간을 문제에 주어진 조건을 만족하면서 매칭할 수 있는지 여부

로 두고 DP를 써서 계산한 다음 역추적했다. $O(N^3)$에 가능하지만 과하게 복잡하게 푼 듯

### B. Swapity Swap

$i$번 소가 문제에 주어진 과정을 거치면 어느 위치로 가게되는지를 계산한다고 생각해보자. 같은 위치에서 동일한 과정을 거치면 동일한 위치로 가게되니까(사이클), 이미 방문한 위치에 도착하기 전까지만 시뮬레이션 해두면 항상 동일한 과정을 반복한다는걸 알 수 있다. 또, 가능한 위치가 $N$가지이므로 이러한 사이클의 길이도 $N$보다 클 수 없음을 알 수 있다.

따라서, $O(N^2)$ 시간에 미리 전처리해서 각 소의 위치가 바뀌는 사이클을 계산해 둘 수 있고, 이걸 계산해두면 $K$번 반복한 다음 소의 위치는 $O(1)$에 계산할 수 있다. 따라서 문제를 $O(N^2)$에 해결 가능.

### C. Matrix Cypher

행렬을 구성하는 네 수를 행별로 분리해서 $(a, b)$, $(c, d)$ 라고 하자. 여기에 조건에 따라 행렬을 곱하면 $(a+b, b)$ 와 $(c+d, d)$ 로 바뀌거나, $(a, a+b)$ 와 $(c, c+d)$ 로 바뀌거나 둘 중 하나가 된다. 즉, 최종 행렬에서 왼쪽 수와 오른쪽 수 중 어느 수가 크냐에 따라 비트를 $0$인지 $1$인지 확정할 수 있다. 이 과정을 반복하면서 뺄셈해서 원래의 identity matrix가 나올 때까지 계산해주면 답을 구할 수 있다. 수 범위가 커서 python으로 풀었다.

### D. 나 퇴사임?

dp(day, a, b, p) = 현재 날짜가 day일, 휴식 가능 일수를 a, 자습해야하는 날짜 수를 b, 전날에 휴게소를 썼는지 여부가 p일 때, 가능한 최대 만족도

라고 정의하면, $O(N^3)$ 에 문제를 해결할 수 있다.

### E. 모빌

트리의 모든 리프 노드 높이 차이가 $1$보다 크면, $-1$을 출력한다.

$0$이면, $0$을 출력한다.

그 외의 경우는 적절히 조작해서 원하는 답을 만들 수 있는지 체크해야하는데, 결국 문제에서 주어진 연산은 트리의 왼쪽 자식과 오른쪽 자식을 서로 교환하는 것이므로 이 연산만 이용해서 조건을 만족시킬 수 있는지 확인한다.

일단 왼쪽 자식과 오른쪽 자식이 모두 높이가 서로 다른 리프 노드를 포함한다면 항상 불가능하고, 그렇지 않다면 왼쪽 오른쪽을 적절히 바꿔서 답을 만들어줄 수 있다. dfs를 하면서 이 과정을 적절히 조건 체크해서 필요한 횟수를 계산해주면 답을 구할 수 있다.

### F. 단어 검색

trie를 이용해서 문제를 해결할 수 있다. 일단 쿼리한 문자열이 DB에 있는 경우와 DB에 없는 경우 두가지로 나눠서 생각해보자.

1. 쿼리한 문자열이 DB에 없는 경우

이 경우는, f(s, t) = s와 t가 맨 앞에서부터 겹치는 길이 라고 정의하면, DB에 속하는 모든 문자열 $x_i$에 대해 $f(s, x_i) + 1$을 더한게 답이 된다.

이건 trie에 문자열을 추가하는 과정에서 각 노드마다 그 노드에 도달하는 문자열의 개수를 계산해두면 trie를 순회하면서 답을 구할 수 있다.

2. 쿼리한 문자열이 DB에 있는 경우

이 경우는, 나보다 먼저 DB에 추가된 문자열에 대해 위 케이스의 답을 구한 것 + (이번 문자열의 길이) + 1 만큼이 답이 된다. 위 케이스의 답을 구하는 함수를 이미 구현해놓았다면 trie에 현재 문자열을 추가하기 전 시점에서 답을 구해서 전처리해둘 수 있으므로, 이 경우도 마찬가지 방식으로 답을 구할 수 있다.

따라서 트라이를 이용해서 $ O(N+Q) $ 시간에 문제를 해결할 수 있으나, 메모리 제한이 좀 빡빡해서 트라이 구현을 신경써서 해야하는 점이 짜증나는 문제였다.