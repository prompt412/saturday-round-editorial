
## 감상

A번을 읽고 나서 쉬운 풀이가 잘 생각이 안나서 약간 당황했다. 당황해서 B번을 봤는데 B번도 잘 모르겠고, 그래서 C번을 봤는데 C번도 잘 모르겠어서 약간 멘붕.

다시 A번으로 돌아와서 그냥 되게 복잡해보이는 DP를 짜고 맞았는데 다른 사람들은 그리디로 푼 거 같은데 그리디는 잘 모르겠다. 저거 그리디가 실버4는 아닌 것 같은데..? 싶은 생각.

B를 푼 다음에 C를 보니 제한이 $ 2^128 $ 인 점에서 이미 풀기가 싫어져서 건너뛰고 D를 먼저 풀었다. D는 많이 풀어본 유형의 DP라서 비교적 쉽게 풀었고, E를 읽은 다음 E를 풀까 C를 풀까 고민하다 C를 먼저 풀었다. 다시 돌아와서 풀어보니 풀만했다. 그리고 E,F를 순서대로 풀고 마무리. 오늘따라 좀 코딩에 잔실수가 많았던 점이 아쉽다. 정확도를 좀 더 신경써야한다는 생각이 들었다.

## Timeline

### ~00:10

시작하고 A,B,C를 순서대로 읽었다. 셋 다 풀이가 바로 떠오르지는 않아서 뭐부터 풀어야할까 고민하다 그냥 A번으로 돌아와서, 고민하다가 그냥 생각난 복잡하게라도 풀리는 풀이를 짰다.

### 00:12 A - WA

짜서 냈는데 역추적을 잘못 해서 WA.

### 00:14 A - AC

틀린 부분을 고쳐서 맞았다. 평소보다 A번 푸는데 시간도 오래 걸렸고 한 번 틀리기도 하고 해서 약간 마음이 다급해졌다.

### 00:18 B - WA

B,C를 번갈아가며 읽다가 B 풀이가 생각나서 짜서 제출. 소의 위치랑 번호를 헷갈려서 출력이 잘못됐는데 예제가 악랄해서 그런 실수를 해도 예제로는 알 수가 없게 되어 있었다..

### 00:23 B - AC

조금 헤매다가 틀린 부분을 찾고 AC.

### 00:33 D - TLE

C를 읽고 바로 생각이 안나서 D로 넘어갔는데 D가 훨씬 풀만해보여서 생각나는 풀이를 짰다. 다 짜서 제출했는데 제출하고 보니 놀랍게도 메모이제이션을 안하는 실수를 해서.. TLE.

### 00:33 D - WA

바로 그 부분을 찾아서 제출했는데 이번에는 WA가 나왔다. 코드를 다시 보니 B번 이상 자습하는 부분 로직을 잘못 처리한 부분이 있어서 그 부분을 고쳤다.

### 00:35 D - AC

고쳐서 제출 후 AC. 오늘따라 실수도 많고 좀 말린 느낌이 들어서 이 타이밍에 살짝 짜증이 났다.

### 00:46 C - AC

다시 C번으로 돌아와서 식을 정리해보니 풀이가 생각나서 구현 후 제출, AC. 오랜만에 파이썬으로 구현해서 내려니 약간 헤맸다. 문제 풀이랑 전혀 상관없는 2^128 제한을 왜 두는건지 잘모르겠다.. 어쨌든 초반에 좀 말렸다고 생각했는데 C,D를 그래도 꽤 빠르게 풀어서 46분 시점에서 4솔브를 했고, 약간 마음이 편해졌다. EF 두 문제를 고민할 시간은 충분히 있겠다는 생각이 들었다.

### 00:58 E - WA

E번은 읽어보니 조건을 잘 정리하면 그렇게 복잡한 부분은 없는 것 같아서 생각나는 코드를 그대로 옮겨서 제출했다. 하지만 WA.

### 00:59 E - WA

조건을 약간 잘못 생각한게 있어서 한 번 고쳤는데, 그래도 WA가 나왔다.

### 01:01 E - AC

다시 보니까 고친 것도 잘못된 거여서.. 다시 고쳐서 내서 AC. 처음부터 좀 꼼꼼하게 생각해서 정리를 했으면 한 번에 맞았을텐데 대충 생각했다가 패널티만 엄청 쌓았다. 이런 식 정리에서 항상 꼼꼼하지 못한데 습관을 어떻게 들여야할지 잘 모르겠다.

아무튼 E를 생각보다 훨씬 빨리 풀어서 F번은 여유롭게 풀어도 되겠다는 생각이 들었다. F번도 문제를 읽어보니 trie를 쓰는 풀이가 직관적이어서 금방 구현에 들어갈 수 있었다.

### 01:21 F - MLE

다 구현하고 제출했는데, 생각도 못한 메모리 초과가 떠서 약간 당황했다. 다시 보니 메모리 제한이 128MB로 빡빡한 문제였다. 그래서 머리를 좀 굴려서 메모리를 줄일 수 있을만한 부분을 좀 줄이고 다시 제출.

### 01:23 F - MLE

그래도 MLE가 떴다. 아무래도 trie의 각 노드마다 다음 노드 포인터를 배열로 전부 들고 있는 방식으로는 메모리 초과를 피할 수 없을 것 같아서, map을 따로 두고 딱 필요한 만큼의 next 포인터만 만들게끔 바꿔서 다시 제출했다.

### 01:26 F - AC

제출해보니 AC. 초반에 말린 것 같았는데 다행히 후반 문제들을 빠르게 풀어서 되게 빠르게 올솔브를 할 수 있었다. 나머지 시간동안 풀이 에디토리얼을 정리한 후 div2 ABC 문제도 마저 풀고 끝냈다.

## 풀이

### A. Generalized German Quotation

dp(l, r) = l..r 부분 구간을 문제에 주어진 조건을 만족하면서 매칭할 수 있는지 여부

로 두고 DP를 써서 계산한 다음 역추적했다. $O(N^3)$에 가능하지만 과하게 복잡하게 푼 듯

### B. Swapity Swap

$i$번 소가 문제에 주어진 과정을 거치면 어느 위치로 가게되는지를 계산한다고 생각해보자. 같은 위치에서 동일한 과정을 거치면 동일한 위치로 가게되니까(사이클), 이미 방문한 위치에 도착하기 전까지만 시뮬레이션 해두면 항상 동일한 과정을 반복한다는걸 알 수 있다. 또, 가능한 위치가 $N$가지이므로 이러한 사이클의 길이도 $N$보다 클 수 없음을 알 수 있다.

따라서, $O(N^2)$ 시간에 미리 전처리해서 각 소의 위치가 바뀌는 사이클을 계산해 둘 수 있고, 이걸 계산해두면 $K$번 반복한 다음 소의 위치는 $O(1)$에 계산할 수 있다. 따라서 문제를 $O(N^2)$에 해결 가능.

### C. Matrix Cypher

행렬을 구성하는 네 수를 행별로 분리해서 $(a, b)$, $(c, d)$ 라고 하자. 여기에 조건에 따라 행렬을 곱하면 $(a+b, b)$ 와 $(c+d, d)$ 로 바뀌거나, $(a, a+b)$ 와 $(c, c+d)$ 로 바뀌거나 둘 중 하나가 된다. 즉, 최종 행렬에서 왼쪽 수와 오른쪽 수 중 어느 수가 크냐에 따라 비트를 $0$인지 $1$인지 확정할 수 있다. 이 과정을 반복하면서 뺄셈해서 원래의 identity matrix가 나올 때까지 계산해주면 답을 구할 수 있다. 수 범위가 커서 python으로 풀었다.

### D. 나 퇴사임?

dp(day, a, b, p) = 현재 날짜가 day일, 휴식 가능 일수를 a, 자습해야하는 날짜 수를 b, 전날에 휴게소를 썼는지 여부가 p일 때, 가능한 최대 만족도

라고 정의하면, $O(N^3)$ 에 문제를 해결할 수 있다.

### E. 모빌

트리의 모든 리프 노드 높이 차이가 $1$보다 크면, $-1$을 출력한다.

$0$이면, $0$을 출력한다.

그 외의 경우는 적절히 조작해서 원하는 답을 만들 수 있는지 체크해야하는데, 결국 문제에서 주어진 연산은 트리의 왼쪽 자식과 오른쪽 자식을 서로 교환하는 것이므로 이 연산만 이용해서 조건을 만족시킬 수 있는지 확인한다.

일단 왼쪽 자식과 오른쪽 자식이 모두 높이가 서로 다른 리프 노드를 포함한다면 항상 불가능하고, 그렇지 않다면 왼쪽 오른쪽을 적절히 바꿔서 답을 만들어줄 수 있다. dfs를 하면서 이 과정을 적절히 조건 체크해서 필요한 횟수를 계산해주면 답을 구할 수 있다.

### F. 단어 검색

trie를 이용해서 문제를 해결할 수 있다. 일단 쿼리한 문자열이 DB에 있는 경우와 DB에 없는 경우 두가지로 나눠서 생각해보자.

1. 쿼리한 문자열이 DB에 없는 경우

이 경우는, f(s, t) = s와 t가 맨 앞에서부터 겹치는 길이 라고 정의하면, DB에 속하는 모든 문자열 $x_i$에 대해 $f(s, x_i) + 1$을 더한게 답이 된다.

이건 trie에 문자열을 추가하는 과정에서 각 노드마다 그 노드에 도달하는 문자열의 개수를 계산해두면 trie를 순회하면서 답을 구할 수 있다.

2. 쿼리한 문자열이 DB에 있는 경우

이 경우는, 나보다 먼저 DB에 추가된 문자열에 대해 위 케이스의 답을 구한 것 + (이번 문자열의 길이) + 1 만큼이 답이 된다. 위 케이스의 답을 구하는 함수를 이미 구현해놓았다면 trie에 현재 문자열을 추가하기 전 시점에서 답을 구해서 전처리해둘 수 있으므로, 이 경우도 마찬가지 방식으로 답을 구할 수 있다.

따라서 트라이를 이용해서 $ O(N+Q) $ 시간에 문제를 해결할 수 있으나, 메모리 제한이 좀 빡빡해서 트라이 구현을 신경써서 해야하는 점이 짜증나는 문제였다.