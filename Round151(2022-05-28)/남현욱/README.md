
## 감상

여러가지로 완전 말렸는데, 그냥 내가 잘 못하는 파트에서 많이 걸린게 컸던 것 같다. 좀 더 침착하게 했으면 잘 했을 것 같은데 여러모로 아쉽다.

## Timeline

### 00:05 A AC

읽어보고 조건을 정리해보니 풀이가 나와서 풀어서 AC.

### 00:14 C WA

B번을 읽고 일단 문제 이해가 잘 안 됐고, 뭔가 그렇게 쉽게 못 풀겠어서 일단 C로 넘어갔다. C는 풀이가 빨리 생각나서 제출했는데, WA.

### 00:15 C AC

한 가지 예외를 빠트렸다는 걸 깨닫고 그 부분을 처리해서 AC.

### 00:28 B WA

다시 B로 돌아와서, 고민하다 문제를 대충 이해한 거에 맞춰서 생각나는 풀이를 시도해봤는데 WA가 나왔다. 문제를 정확하게 이해한게 맞는지도 오락가락하고 풀이도 오락가락해서 조금 짜증이 났다.

### ~ 00:32

여러번 이렇게 저렇게 바꿔가면서 내 봤는데 전부 WA가 나와서 일단 치워놓고 D로 이동.

### 00:40 D AC

D는 문제를 읽어보니 익숙한 유형이어서 금방 짜서 맞았다. 그리고 다시 B를 볼까 E를 볼까 고민하다가 B 풀기가 싫어서 E로 넘어갔다. E도 근데 읽어보니 만만치 않았고, F는 읽어보니 풀이가 각이 잡히긴 했는데 구현이 좀 귀찮아보였다. 그래서 B,E,F 중에 고민하다가 먼저 E를 풀고 시간이 되면 B->F 순으로 봐야지 라고 전략을 세우고 E 풀이를 고민해봤다.

### ~02:00

하지만 여기서 온갖 시도들이 전부 실패로 돌아가고.. 마지막에 짰던 풀이도 틀린 풀이였는데 디버깅에마저 실패해서 시간만 엄청 낭비하다가 시간 종료. E를 적당한 시점에 버리고 B,F를 보는게 더 좋은 전략이었을 것 같은데 될 것 같다는 느낌에 붙잡혀서 시간을 너무 오래 쓴게 문제였던 것 같다.

## 풀이

### A. queuestack

결국 스택은 의미가 없고, 순차적으로 큐에 든 원소들은 하나씩 다음 큐로 이동한다. 따라서 모든 큐를 그냥 하나의 큐로 생각하고 관리하면 문제를 해결할 수 있다.

### B. Measuring Traffic

$N$ 제한이 미묘하게 작아서 시작 트래픽을 고정해놓고 전부 시뮬레이션해서 모순이 없는지를 보는 식으로 접근하려고 했었는데 뭔가 잘 안 됐다.

그냥 맨 뒤에서 / 맨 앞에서부터 보면서 순차적으로 조건을 처리해주면 답을 구할 수 있다. 이 때, 값이 0 아래로 내려가는 경우 그냥 0으로 바운드를 맞춰주는 예외 처리가 필요한데 이 부분이 좀 찜찜하다...

### C. Corrupt Judge

시간 패널티가 더 작아지는 경우에는 반드시 문제 수가 1개 이상 차이가 나야한다. 따라서 이를 이용해 해당 스코어보드를 구성하기 위한 최소 문제수를 구할 수 있고, 이 수와 $p$가 일치하지 않는다면 무조건 ambiguous하다. 일치한다면, 순서대로 해당 차이나는 지점마다 문제수를 1개씩 늘려나가면서 스코어보드를 복구하는 것도 쉽게 해결가능하다.

여기서 몇 가지 예외 처리가 필요한데, 패널티가 0이면 무조건 0문제를 푼거라는 점을 고려해주어야 한다. 꼴등이 패널티가 0이 아니라면 꼴등이 최소 1문제 이상 풀었고, 1등이 패널티가 0이라면 모든 사람이 전체 문제수에 상관없이 0문제를 푼 것이다. 이 두가지 예외만 잘 처리해주면 정답을 맞을 수 있다.

### D. 본대 산책 3

$ DP(a, b, k) $ 를 $a$ 에서 $b$ 까지 정확히 $k$ 분이 걸려서 도달 가능한 경우의 수 라고 하자.

이렇게 정의하면,

$ DP(a, b, 2 \cdot k) = \sum_{m=1..n} DP(a, m, k) \cdot DP(m, b, k) $ 임이 성립한다.

이를 이용하면 $k$ 번 DP 테이블을 계산했을 때 이를 이용해서 $ 2 \cdot k $ 번 DP 테이블을 $O(N^3)$ 시간에 구할 수 있다. 따라서 빠른 거듭제곱법과 동일한 방식으로 주어진 문제를 $O(N^3logK)$  시간에 해결할 수 있다.

### E. 효율적으로 소 사기

그리디하게 접근해보자. 쿠폰을 써서 최대한 싼 가격의 소들을 가능한 한 많이 샀다고 치고($K$ 마리), 여기서 새로운 소를 사는 경우를 생각해보자. 새 소의 가격은 $P_i$ 원이거나, $C_i$ 원인데, 여기서 쿠폰을 쓰려면 기존에 썼던 쿠폰 하나를 쿠폰을 안 쓴 걸로 바꿔야만 한다. 이 때 기존에 선택한 어떤 $j$번 소를 다시 되돌린다고 생각하면, $P_j - C_j$ 원만큼의 추가적인 비용이 발생한다.

따라서, $P_i$ 와 $C_i + P_j - C_j$ 원 중에 가격이 더 싼 것을 고르는게 이득이다. 이 때 기존에 선택한 것 중에서도 최대한 가격 차이가 적은 것($P_j - C_j$ 값이 작은 것)을 다시 되돌리는게 가장 이득이 된다.

이러한 관리는 우선순위 큐를 이용해서 쉽게 처리해줄 수 있다. 모든 $P_i$, $C_i$, 선택한 것들에 대한 $P_i-C_i$ 값을 전부 우선순위큐로 관리하면, $x$마리 소를 고른 시점에서 최대한 적은 비용으로 $x+1$ 마리 소를 고르는 방법을 구현할 수 있다.

따라서 문제를 $O(NlogN)$ 시간에 해결할 수 있다.

연습 시간 중에는 이상한 그리디 알고리즘으로 증명을 제대로 하지 않고 접근했다가 틀렸다. 끝나고 답지를 보고 풀이를 이해한 다음에 풀었는데, 여전히 엄밀한 증명은 잘 모르겠다. 공식 풀이에 적힌 것도 딱히 증명이 엄밀해보이지는 않고.. 이런 그리디 문제에 항상 약한데 어떤 식으로 해야할지 잘 모르겠는 기분. 그리디는 참 연습도 어렵고 실력도 잘 안 느는 것 같다.

### F. 그릇 쌓기

모든 그릇을 하나로 합쳤을 때 높이 배열은 정해져 있고, 이를 각각의 첫 그릇 더미에 어떻게 배분할까를 따지는 문제로 생각할 수 있다.

또, 한 그릇 더미에 높이가 연속한게 여러개 있을 경우 그 구간은 반드시 같은 그릇 더미로 채우는게 이득이므로 한 그릇 더미를 이루는 높이는 모두 서로 다른 값으로 가정해도 좋다(중복이 있으면 삭제하고 시작).

이제 다음과 같은 식을 정의하고 시작해보자.

$DP(i, last)$ = 전체를 하나로 합친 그를 더미에서 $i$번째에서 마지막 그릇까지를 각 그릇 더미에 배분하되, 그릇 더미가 교체되는 횟수를 최소로 했을 때 교체 횟수. $last$는 $i-1$번째 그릇을 할당한 그릇 더미 번호.

이렇게 할 경우, $2 \cdot DP(0, 0)- (n+1)$ 이 답이 된다. 왜냐하면, 그릇을 한 번 자르면 결국 다시 붙여야하기 때문에 두 번의 연산이 필요한데($2 \cdot DP(0, 0)$), 맨 처음 할당되는 그릇 더미들은 한 번만 합치면 되며, 그중에서도 맨 밑에 들어갈 그릇더미는 합치는 연산이 필요하지 않으므로 실제로 횟수를 소모하지 않는 $n+1$번의 연산은 빼 주면 원하는 답이 되기 때문이다.

이제 저 DP 식을 구해야하는데, 이 때는 결국 서로 높이가 같은 그릇들에 대해 그릇 더미를 어떤 순서로 배분하냐에 따라서만 필요한 연산 횟수가 달라진다. 이것도 그 그릇들의 중간 순서는 어차피 어떻게 바뀌든 필요한 횟수가 같고 맨 마지막 그릇을 어디 할당할지 만이 중요하므로, 마지막 그릇에 배분할 더미를 고정하고 각 경우에 대해 답을 구해주면, $O(N^4)$ 에 문제를 해결할 수 있다.
