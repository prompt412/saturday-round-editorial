## 문제별 풀이 과정

### 1. [queuestack](https://www.acmicpc.net/problem/24511)

- 문제를 처음 보고 queue/stack을 $N$(~$100000$)개 만든 다음에 하나씩 푸는 방법을 생각했는데 complexity가 $O(NM)$이 나와 불가능하다는 걸 깨달았다.
- 당황해서 망설이다가, 문제의 예제를 손으로 그려가면서 풀어보니 stack을 무시하고 queue가 일렬로 이어져 있는 모양이라는 걸 알 수 있었다.

### 2. [Measuring Traffic](https://www.acmicpc.net/problem/17041)

- 2, 3번 둘 다 영어라 뭘 먼저 풀지 고민하다가 현욱님이 3번을 먼저 푸셔서 따라서 3번을 풀고 2번은 나중에 풀게 되었다.
- 입력이 항상 valid하대서, [-inf, inf]에서 시작해서 맨 뒤에서부터 역산해서 출발점의 범위를 구했고, 구한 출발점의 범위를 가지고 다시 맨 뒤까지 계산해서 도착점의 범위를 구했다.
- Invalid한 입력이 있는 경우에는 left > right일 때 fail처리를 해주면 될 거 같긴 한데 확신은 없다.

### 3. [Corrupt Judge](https://www.acmicpc.net/problem/20331)

- 1등이 모든 문제를 다 풀었다고 가정한 뒤에,  $a_{i} > a_{i+1}$인 경우에 푼 문제의 수를 1 감소시켜주는 방식으로 처음에 풀었다가 틀렸다.
- Timescore가 0인 경우에 1문제도 안 푼 거라는 설명을 놓쳤다는 걸 깨닫고 추가 처리를 해줬는데도 틀렸다.
- 도무지 반례를 못 찾겠어서 일단 D를 풀고 와서 다시 들여다보니, 모두 0점인 경우도 valid하다는 게 그제야 보였다. 추가 처리를 해줘서 3트만에 풀었다.

### 4. [본대 산책 3](https://www.acmicpc.net/problem/14289)

- 1e9+7로 나눈 나머지를 구하라길래 DP인 줄 알고 식을 세우는데 도무지 답이 안 보였다. 
- D가 엄청 커서 parametric search인가 싶어서 모델링해보는데 그래도 답이 안 보였다.
- 그러다가 모든 이동이 1분이 소요되고 중간에 멈추는 경우도 없다는 조건을 봤다. 문제를 꼼꼼하게 안 본 탓이다.
- Vertex가 3개 있는 완전 그래프의 경우를 그려보니, 이동 가능 여부를 0/1로 표시한 NxN 행렬 m이 주어졌을 때, i에서 j로 가는 방법의 수가 $ (m^3)_{i, j} $ 라는 걸 알 수 있었다. 빠른 거듭제곱으로 풀었다.

### 5. [효율적으로 소 사기](https://www.acmicpc.net/problem/5896)

- 결론부터 말하면, 오답을 제출했는데 정답으로 처리가 됐다.

#### 풀이 과정

- 주어진 예제에 소 한두 마리를 더 추가해서 손으로 풀어보니까 쿠폰 값이 가장 싼 소부터 산 다음에, 여분의 쿠폰이 없는데 쿠폰을 쓴 경우보다 할인 폭이 크다면 이전 쿠폰을 물리고 새 소를 쿠폰으로 사면 되는 거 같았다.
- 소 가격을 쿠폰가 기준으로 정렬한 뒤 min heap에 할인 폭을 넣으면서 풀었는데 WA가 나왔다.
- 혹시나 해서 소 가격을 (쿠폰가, 정상가)로 정렬한 뒤에 다시 제출했는데 AC가 나왔다. 의아하긴 했지만 맞았으니 일단 넘어갔다.

#### 끝나고 나서

- 토요라운드가 끝나고 생각해보는데 도무지 (쿠폰가, 정상가)로 정렬했다고 풀리는 이유가 납득이 안 됐고 결국 저녁 늦게 [반례](https://www.acmicpc.net/board/view/91386)가 떠올랐다.
- 아래와 같이 푸니까 위의 케이스를 포함해서 AC가 나왔다:
  1. 쿠폰가로 정렬한 뒤에 앞의 소부터 `heap.size() == K`가 될 때까지 구매한다.
  1. 방금의 구매 이후에 배열 뒤쪽에 남은 소들을 정상가 기준으로 정렬한다.
  1. 정렬된 순으로 남은 소들을 보면서 기존보다 더 크게 할인받을 수 있다면 이전 쿠폰을 물리고 현재 소를 쿠폰으로 사고, 그게 안 되지만 정상가로도 소를 살 수 있다면 사준다.
- 더 많이 살 수 있는 경우가 있다고 가정하면, 쿠폰가로 산 소가 더 많을 수도 없고 정상가로 산 소가 더 많을 수도 없다는 걸 보여서 증명할 수 있어보인다.
  - 컨테스트에서 증명까지 하기에는 케이스가 너무 복잡해보이긴 한다.

### 6. [그릇 쌓기](https://www.acmicpc.net/problem/4213)

- N이 작아서 flow인가 했다가 잘 모르겠고 시간이 없어서 넘어갔다.
- 현욱님 풀이를 보니까 DP였다. DP 공부를 꼭 한 번 몰아서 해줘야겠다.
