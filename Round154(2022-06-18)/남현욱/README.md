
## 감상

오늘은 코딩 실수가 좀 많았다. 거기에 E번이 옛날 문제라 엄청 이상한 입출력 포맷을 가지고 있어서 시간 낭비를 많이한 다음에 멘탈에 타격을 입어서 그 뒤 문제를 잘 못 푼 것 같다. G번은 문제도 잘못 읽고 나중에 마음이 급해져서 이상한 풀이만 자꾸 시도하고 하는 등 안 좋은 버릇이 나왔다. 중간에 좀 예상치 못한 이유로 시간을 많이 쓰거나 하면 페이스가 흐트러지는데 이걸 더 신경 쓸 필요가 있겠다고 생각했다.

## 풀이

### A. I am Groot

문제에 적힌 규칙에 따라 시뮬레이션을 해주면 된다. 개수를 2배씩 늘려주고, 나뭇가지 길이 변화를 문제에 주어진 조건에 따라 처리해주고, 전체 합을 계산하면 된다. 답의 크기가 아주 커질 수 있음에 주의.

### B. 베스킨라빈스 31

isWin(n, p) = 조건에 따라 $1 \dots n $까지 부를 수 있을 때, 그리고 이전에 마지막으로 불린 수가 $p$일 때 이번 차례가 이기는지 여부 라고 하자.

이 상태에서 내가 할 수 있는 건 $p+1$을 부르기, $p+2$를 부르기, ..., $p+n$을 부르기 중 하나이다. 이 중에서 하나라도 다음 상대가 지는 경우가 있다면 내가 이기고, 그게 아니라면 내가 진다.

이 논리에 따라 점화식을 세우면 DP로 문제를 해결할 수 있다.

### C. 다이나믹 롤러

결국 내 오른쪽에서 $A_i$보다 큰 첫 번째 $B$를 찾으면 문제를 해결할 수 있다. $B$가 오름차순이므로, 투 포인터를 써도 되고 이분 탐색을 써도 된다. 나는 구현 편의성 때문에 이분 탐색으로 풀었다.

### D. 소변기

A번이랑 비슷하게 문제에 적힌 규칙에 따라 시뮬레이션을 해주면 된다. 지문이 좀 애매해서 헷갈렸다.

### E. Bit Maps

BOJ에서 종종 있는 쿼드 트리류 문제의 응용편. 적힌 인코딩 규칙대로 재귀적으로 입력을 인코딩 / 디코딩해주면 되지만, 옛날 문제라 입출력 포맷이 엉망이어서 이 부분에서 시간을 너무 많이 썼다.

### F. 행렬 만들기

더 쉬운 규칙이 있을 것 같긴 한데 생각하기 귀찮아서 네트워크 플로우로 풀었다.

(소스) - (행) - (열) - (싱크) 형태로 구성하고, 각 행, 열의 합을 각각 소스, 싱크와 연결된 capacity로, 각각의 행과 열을 capacity가 1인 간선으로 이어주면 주어진 조건을 만족하는 매칭을 찾을 수 있다.

(행 합) = (열 합) = (max flow)면 답이 존재하는 것이고, 존재하는 경우 각 간선을 하나씩 확인해보면서 $ flow = capacity = 1 $인 간선을 모두 찾아주면 조건을 만족하는 행렬 복구도 가능하다.

### G. Circular Barn (Gold)

$1, 2, \dots, N$ 번 방에 각각 소가 한마리씩 있고 각 소를 적절히 옮겨서 $i$번 방에 $C_i$ 마리의 소가 있게 한다고 생각해도 문제는 달라지지 않는다. 이렇게 바꿔놓고 생각해보자. 어떤 $i$번 소와 $j$번 소에 대해($ i \lt j $), 각 소가 최종적으로 도착하는 방을 $R_i, R_j$라고 해보자. $i \lt j$이면 $R_i \le R_j$ 임을 만족해야한다. 합이 거리의 제곱에 비례하기 때문에 반대인 경우 서로 순서를 바꾸는게 필요 에너지가 줄어들기 때문이다.

따라서, 모든 소는 순서대로 본인이 방문하는 방이 오름차순이어야 한다. 따라서, $S_i \ge i$를 만족하는 $S_i$ 배열만 찾아 주면 문제를 해결할 수 있다. 

이 때 주어진 $C$ 값에 따라 방문해야 하는 목적지를 늘어놓은 결과를 $X_i$라고 하면, $X_i - i + k \ge 0 $이 되게 만드는 최소 $k$지점부터 순서대로 방을 할당해주면 항상 조건을 만족시킬 수 있다. 따라서 $O(N)$에 문제를 해결할 수 있다.

### H. 전구

연산을 수행하는 순서는 중요하지 않다는 사실을 알 수 있다. 좌우는 길이를 마음대로 할 수 있지만 위아래는 같이 선택하는 경우 두줄을 한꺼번에 선택하는 한 가지 경우밖에 없으므로, 위아래를 선택하는 연산을 먼저 수행한다고 생각해보자.

위아래 연산을 먼저 다 끝내 놓고 나면, 위 아래 각각의 줄에는 1이 연속한 구간들이 여러개 나타난다. 이 구간을 모두 만들어주는 최소 연산 횟수는 그냥 연속한 1 구간 개수와 동일하다.

따라서, dp(i,u,d) = $i \dots n $번째를 전부 주어진 패턴대로 만들되, $i-1$번 라인에서 위쪽은 $u$, 아래쪽은 $d$일 때 필요한 연산 횟수

라고 정의하고 풀면 $O(N)$에 문제를 해결할 수 있다.