# Round 149 (Div 1) 후기

## 전반적인 소감

- 1번 문제에 생각보다 시간을 많이 쓰긴 했지만, 적절한 시간에 미련을 버리고 다음 문제로 넘어가길 잘했다.
- 다행히 나머지 문제들이 빨리 풀려서 5번까지 밀 수 있었다.
- 다 풀고 시간이 5분 정도 남아, 5솔과 6솔 사이의 간극이 크다는 생각을 했다.

## 문제별 풀이과정

### 1. [약속](https://www.acmicpc.net/problem/1183)

- 가장 오래 걸린 문제였다. 어떻게 풀어야 할지 감이 오지 않았다.
- 처음에는 약속 시간을 미뤄야 하는 경우, 앞당겨야 하는 경우, 지금이 괜찮은 경우 셋으로 나눠서 풀려고 했다. 하지만 분기가 복잡해져서 코드를 감당할 자신이 없었다.
- 일단 다른 문제를 풀다가 돌아와서 다시 생각하다보니, T를 -inf로 놓은 다음에 조금씩 증가시키다 보면 어느 $a_i$와 $b_i$가 만나는 순간부터 바로 다음 $a_j$와 $b_j$가 만나는 순간까지 min이 된다는 걸 알 수 있었다.
  - 즉, 해당 구간의 T의 최대/최소값은 모두 $b_k - a_k for some k$이고, 그러한 구간은 하나만 존재한다는 얘기다.
- 그래서 모든 $b_i - a_i$에 대해 총합을 구하고, 총합이 min일 때의 $b_i - a_i$의 최대값 - 최소값을 답으로 냈다.
- 정렬한 뒤에 가운데 두 값의 차이를 출력하는 게 연우님 답안인데 아직도 저 직관은 잘 와닿지 않는다.

### 2. [4 thought](https://www.acmicpc.net/problem/10487)

- 테스트 케이스는 총 1000개인데, 가능한 경우의 수가 $4^3 = 64$가지밖에 없다.
- 각 케이스별로 64가지의 수식을 모두 계산하여 답이 되는 수식이 있는지 확인했다.
- size 4짜리 num array, size 3짜리 operator array를 관리하면서 곱하기와 나누기가 있는지 먼저 체크한 뒤 더하기와 빼기를 체크했다.
- 지나고 보니 프로그램 init 단계에서 64가지를 모두 계산해서 string을 map에 넣어둔 다음에, 각 케이스별로 map lookup을 한 번씩만 해도 됐을 거 같지만 큰 차이는 없었을 거다.

### 3. [인성 문제 있어??](https://www.acmicpc.net/problem/19952)

- 2020년도 contest인데 무싸트 얘기가 나오는 걸 보고 가짜사나이가 나온지 벌써 2년이 됐다는 걸 알게 됐다..
- 2D board에서 BFS를 쓰는 일반적인 문제인데, 다음 cell을 방문할 수 있을지 확인할 때 높이 정보를 체크하는 게 추가된 형태였다.
- 다음 cell의 높이 차이 이상이어야 하는 게 현재 force인지 다음 force인지 확인하는 게 조금 귀찮았다.
- 토요라운드 당시에는 `max_force` 2D 배열을 하나 관리하면서 `cur_force >= max_force`일 때에만 방문하도록 했는데, BFS면 `visited <=> cur_force <= max_force`이므로 그렇게까지 할 필요는 없었다.
  - 물론 똑같이 공간을 잡아 먹고 각 cell별로 어셈블리 명령어 몇 개만 차이가 났겠지만.
- 중간에 PyPy3에 놓고 C++ 코드를 제출해서 컴파일 에러가 났는데 오답 제출로 카운트가 안 됐다. '틀렸습니다'만 카운트되는 거 같다.

### 4. [연산 최대로](https://www.acmicpc.net/problem/21943)

- 연산식에 더하기와 곱하기 연산자의 위치가 정해져 있을 때 수식의 값을 최대로 하는 건 곱하기 사이의 모든 덧셈을 괄호로 묶는 거다.
  - ex. $1+2*3*4+5$ -> $(1+2)*3*(4+5)$
- 따라서 곱하기 연산자가 Q개 있으면, 주어진 수를 Q+1개의 묶음으로 묶은 뒤 각 묶음의 합의 곱의 최댓값을 구하면 된다.
- 주어진 그룹을 Q+1개로 쪼개는 방법은 여러 가지인데, 가장 구현이 빠를 거 같은 게 완전 탐색이었다.
  - 0부터 $(Q+1)^N - 1$까지의 수를 N자리 (Q+1)진법 수로 생각하면, i번째 자리의 값이 $a_i$가 들어갈 그룹 번호다.
- 문제의 조건에서 Q의 최댓값이 7이라서 0부터 8^8까지를 순회하면 되고, 각 숫자마다 (Q+1)진법으로 바꾼 뒤 i번째 자리를 적절한 그룹에 넣어줘야 해서 총 O(8^8 * 8) ~= O(1.3억)이 나왔다.
- 보통 O(1억)이 1초인데 돌려보니까 900ms가 나와서 통과했다. 운이 좋았다.
- 더 좋은 풀이는 backtracking을 써서 더 이상 (Q+1)개의 그룹으로 나눌 수 없는 경우에 early return을 해주는 방법인 거 같다.

### 5. [달리는 게임](https://www.acmicpc.net/problem/11388)

- 최대 점수를 구하기 위해서는 곱 계수가 언제 리셋되는지를 알아야 한다.
- 근데 1번부터 3번까지 연속으로 먹었다면, 1\*a1 + 2\*a2 + 3\*a3 = (a3) + (a2 + a3) + (a1 + a2 + a3)이 점수가 된다.
- 문제 설명은 앞에서부터 차례로 먹는다고 되어 있지만 실제 점수의 총합은 뒤에서부터의 running sum을 계속 더해가는 꼴이라, 뒤에서부터 계속 먹어가다가 언제 리셋해야 할지를 생각해보기로 했다.
- \[100, -1, -1, -1, -1, 3\]을 예시로 들어서 뒤에서부터 더하다보니, 총합에 running sum을 계속 더해가다 running sum이 음수가 될 때 0으로 리셋해야 최댓값이 나온다는 걸 알 수 있었다.
- 이번 라운드 문제 중에서 난이도는 높은 편이었으나 풀이는 가장 짧은 문제였다.

### 6. [Black Vienna](https://www.acmicpc.net/problem/11678)

- 문제를 제대로 해석하지 못했다. 예제 입력에서 `AB 1 1`가 뭘 의미하는지 아직도 잘 모르겠다.
- `AB 1 1, AC 2 1, BC 2 1`이면 AB AC BC 뭘 선택하든 1개만 해당되어야 하는데 그런 조합은 나오지가 않는다.
- 다시 봐야겠지만 넘기기로 했다.
