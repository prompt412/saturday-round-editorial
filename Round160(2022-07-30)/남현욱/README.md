
# 풀이

내가 일반적으로 문제를 해결할 때 접근하는 과정을 기준으로 문제를 정리해보았다.

대부분의 경우

1. 문제를 읽고 정리해서 문제에서 구하고자 하는 바를 최대한 간단하게 정리한다.
2. 정리된 내용을 기반으로 그 문제를 해결할 수 있는 나이브(가장 직관적으로 생각할 수 있는 방법, 일반적으로 brute-force)한 알고리즘을 생각한다.
3. 나이브한 알고리즘으로 충분하지 않다면, 문제의 입력 조건이나 문제 자체의 특성을 이용해서 최적화할 수 있는 부분이 무엇일지 고민해본다.
4. 문제를 해결 가능한 알고리즘을 생각했다면 그 알고리즘이 정당한지 고민해본다. 정당성을 증명하고 구현을 해서 해결가능하다는 확실히 들면 그 때 구현에 들어간다.

의 과정을 거치기 때문에 여기에 맞춰서 썼다.

## A. 카카오뷰 큐레이팅 효용성 분석

문제 요약) $N$ 개의 정수 배열 $A$와 $B$가 주어진다. $B$는 0또는 1로만 구성되어 있다. 이 때 $A$에 속하는 모든 정수의 합과, $B_i = 1$을 만족하는 $A_i$의 합을 출력하라.

두 과정 모두 $O(N)$에 반복문을 돌면서 구할 수 있다. 이 나이브한 방법으로도 문제가 해결되는게 명확하므로, 그 방법을 그대로 구현해서 $O(N)$에 해결가능하다.

## B. Q-인덱스

문제 요약) $N$ 개의 정수가 주어진다. 이 정수 중에서 $K$ 이상인 수가 $K$개 이상이고, 나머지 $N-K$개 수가 $K$ 이하인 가장 큰 $K$를 찾아서 출력하라.

가장 나이브한 방법을 생각해보자. 어떤 수 $K$가 답이 되는지 확인하는 과정은 쉽다. $N$개의 정수를 모두 확인하면서, $K$ 이상인 수의 개수를 세고 이게 $K$개 이상이면 그 수는 답이 될 수 있다. 이런 과정은 $O(N)$에 수행가능하다.

그러면, 가능한 가장 큰 $K$부터 시작해서 수를 1씩 감소시켜가며 이 과정을 반복하다가 조건을 만족하는 수가 나왔을 때 그 수를 출력하면 답이 될 것이다. $K$가 답이 되려면 $K$이상인 수가 $K$개 이상이어야 하므로, 가능한 $K$의 최댓값이 $N$임은 명확하다. 따라서 $N$부터 시작해서 모든 과정을 반복해주면 전체 시간복잡도는 $O(N^2)$이 된다. 문제에서 주어진 $N$ 제한이 1000이므로 이 방법으로 바로 문제를 해결할 수 있다.

## C. 척 노리스

문제 요약) $A_N$ 은 $N$으로 시작하는 가장 작은 4의 배수이다. $A_1,A_2,A_3, \dots,$를 전부 이어붙인 무한히 긴 문자열을 생각해보자. 이 문자열에서 $K$번째 수가 뭔지를 찾아서 출력하라.

가장 나이브한 방법을 생각해보자. 길이가 $K$이상이 될 때까지 $A_1$부터 순서대로 모든 값을 구해서 이어붙인다. 그리고 그 때 $K$번째 수를 출력하면 $O(K)$에 문제를 해결할 수 있다.

하지만, 이 방법은 $K$ 제한이 너무 커서 시간 제한을 초과하게 된다. 어떻게 하면 최적화 할 수 있을까? 위에서 제시한 나이브한 알고리즘을 최적화할만한 여지가 있는지 생각해보자. 길이가 $K$ 이상이 될 때까지 일일히 이어붙여서 문제를 해결하려고 했는데, 이 과정을 좀 더 빠르게 할 수는 없을까? 이 과정을 빠르게 계산할 수 있다면 답도 빠르게 구할 수 있을 것이다.

처음부터 일일히 이어붙이지 않고도 길이가 $K$ 이상이 되는 경우를 빠르게 찾을 수 있다면, 일일히 이어붙이지 않아도 길이 계산 자체를 빠르게 할 수 있다는 의미다. 단서가 없으니, 어떻게 하면 $A_1$부터 $A_N$까지 이어붙인 문자열의 길이를 빠르게 계산할 수 있는지부터 생각해보자.

일단, $A_i$ 값을 나열해보면 다음과 같다. 12, 20, 32, 4, 52, 60, 72, 8, 92, 100, 112, 12, 132, 140, 152, 16, ...

4의 배수는 주어진 수의 맨 끝 2자리가 4의 배수면 전체 수도 4의 배수이다(배수 판별법). 따라서, 주어진 수가 4의 배수가 아니라면 딱 한 개의 수만 덧붙여서 4의 배수로 만들 수 있다. 그리고 이미 4의 배수라면 어떤 수도 덧붙일 필요가 없다.

이로부터, $A_i$의 길이를 유도할 수 있다.

- $i$가 $d$자리수일 때, $i$가 4의 배수면 $d$, 아니면 $d+1$

그렇다면 같은 자리수의 $i$에 대해 $A_i$ 길이 합은 한 번에 묶어서 계산할 수 있음을 알 수 있다. 해당 범위의 4의 배수 개수와 그렇지 않은 수의 개수를 구해서 각각의 길이를 곱한 후 더해주면 되고, 4의 배수 개수도 나눗셈을 통해 구할 수 있기 때문이다.

따라서, $N$의 자릿수에 비례하는 시간에 길이 합을 계산할 수 있다. 자릿수는 로그 단위이므로, $A_1$ 부터 $A_N$까지 이어붙인 문자열의 길이는 $O(logN)$ 시간에 구할 수 있음을 알 수 있다.

$A_1$부터 $A_N$까지 이어붙인 문자열의 길이가 $K$이상이 되는 가장 작은 $N$을 찾아야 문제를 해결할 수 있으니, 원래의 문제로 돌아가서 지금 찾아낸 성질을 통해 이 문제를 빠르게 해결할 수 있는 방법이 있는지 고민해보자.

$N$이 커질수록 전체 문자열의 길이가 길어지는 성질이 있으므로, 어떤 $N$을 기준으로 $N$이상 범위에서는 길이가 전부 $K$이상이고, 나머지 범위에서는 길이가 $K$ 미만인 $N$이 존재할 것이다. 이렇게 전체 구간이 반으로 나뉘면, 파라메트릭 서치를 통해 주어진 $N$을 빠르게 찾을 수 있음을 알고 있다.

따라서 파라메트릭 서치를 이용해 $A_1$ 부터 $A_N$까지 길이 합이 $K$이상이 되는 가장 작은 $N$을 찾으면, $K$번째 문자는 $A_N$에 속할 것이므로 여기서 $K$번째 문자도 쉽게 찾을 수 있다. 파라메트릭 서치의 진행횟수는 최대 $O(logK)$이고, 각 서치 단계에서 길이 계산에 다시 $O(logK)$의 시간이 걸리므로, 전체 시간복잡도는 $O(log^2K)$가 된다. $K$ 범위상 이 복잡도의 알고리즘이면 충분히 문제를 해결할 수 있다.

## D. Defend the CTP!!!

문제 요약) 유향 그래프가 주어진다. 이 그래프의 정점 $C_1, C_2, \dots, C_T$가 주어졌을 때, $1$번 정점에서 $C_i$번 정점을 방문한 후, $C_i$번 정점에서 $N$번 정점에 도달하는게 가능한지 판별하라.

가장 나이브한 방법을 생각해보자. BFS혹은 DFS를 이용한 탐색으로 어떤 정점 $x$에서 $y$에 도달가능한지 $O(N+M)$ 시간에 판별가능하다. 그러면 각각의 $C_i$에 대해, $1$번 정점에서 $C_i$에 도달가능한지, 그리고 $C_i$에서 $N$에 도달가능한지 BFS/DFS를 이용해 탐색하면 $O(T(N+M))$ 시간에 문제를 해결가능하다.

하지만, 이 방법은 $T$ 제한이 커서 시간 제한을 초과하게 된다. 탐색 횟수가 굉장히 많은데, 이 횟수를 줄일 수 있는 방법이 있는지 고민해보자. 일단, BFS / DFS가 가지고 있는 특성을 다시 생각해보자. 이러한 탐색은, 어떤 정점 $x$에서 $y$에 도달 가능한지를 $O(N+M)$에 판별가능할 뿐 아니라, $x$에서 다른 모든 정점 $i$에 도달가능한지 여부를 $O(N+M)$에 판별할 수 있다. 즉, 한 번의 탐색으로 어떤 정점에서 시작해서 다른 모든 정점으로 가는 경우를 확인가능하다는 뜻이다.

$1$번 정점과 $N$번 정점은 고정적이니 이 성질을 이용할 여지가 있지 않을까? 일단 $1$번 정점에서 $C_i$로 갈 수 있는지는 탐색 한 번에 확인 가능하다는 것을 유도할 수 있다. 그렇다면, $C_i$에서 $N$으로 가는 경우는 어떻게 할 수 있을까? 시작점이 고정되어 있을 때 모든 끝점은 확인할 수 있지만 이 경우는 끝점이 고정되어 있을 때 모든 시작점을 확인해야한다.

이 때, 그래프의 각 간선 방향을 거꾸로 뒤집으면, 시작점이 끝점이 되고 끝점이 시작점이 되므로 마찬가지 방법으로 구할 수 있게 된다. 따라서, 그래프의 각 간선을 뒤집은 새로운 그래프를 하나 만든 후 이 그래프에서 $N$번 정점에서 시작해서 $C_i$에 도달가능한 경우가 있는지 계산해둔다. 이 두가지 경우가 모두 가능하다면 $C_i$번 정점은 조건을 만족하는게 된다. 탐색 두 번이면 모든 과정을 끝마칠 수 있으므로, 전체 시간복잡도는 $O(N+M)$이 되며 이는 문제를 해결하는데 충분한 시간복잡도다.

## E. Cracking The Safe

문제 요약) 0,1,2,3 중 하나의 수로 구성된 3x3 크기 행렬이 주어진다. 어떤 $(r,c)$ 버튼을 누르면 $(r,c)$와 열이 같거나 행이 같은 위치에 있는 모든 수의 값이 1증가한다. 증가한 수가 4라면 0으로 바뀐다. 이 때, 행렬의 모든 칸을 0으로 만들 수 있는 최소 연산 횟수를 출력하라. 불가능하다면 -1 출력.

가장 나이브한 방법을 생각해보자. 3x3 크기의 모든 위치에 대해 버튼을 눌러보는 모든 경우를 확인해보면 답을 구할 수 있을 것이다. 이 때, 같은 칸을 4번 이상 누르면 모든 칸의 값이 원래 위치로 돌아오기 때문에 한 칸을 누르는 횟수의 경우의 수는 0,1,2,3의 4가지 경우밖에 없음을 알 수 있다.

따라서, 각 칸을 누르는 경우의 수를 합치면 $O(4^9)$가 되고, 이 각각의 경우에 대해 누른 칸을 갱신해주는데 5~6회의 연산, 모든 칸이 0인지 확인하는데 9회의 연산 정도가 필요하므로 상수는 여기에 10배 정도를 곱해주어야 한다. $4^9 = 262144$고 여기에 10배 정도를 곱해줘도 백만 범위이므로 문제를 해결하는데에는 충분하다. 따라서 이 나이브 알고리즘으로도 문제를 푸는데 충분하다.

## F. Frosh Week

문제 요약) 배열이 주어져있을 때, 인접한 두 수를 서로 교환하는 연산만으로 해당 배열을 정렬하는데 필요한 최소 연산 횟수를 구하여라.

세그먼트 트리 혹은 병합 정렬을 이용해서 $O(NlogN)$에 이러한 문제를 해결하는 방법이 알려져있다. 이 방법을 그대로 구현하면 문제를 해결할 수 있다.

## G. Cow Photographs

문제 요약) F와 동일하게 인접한 두수를 교환하는 연산만으로 배열을 정렬하는데 필요한 최소 연산 횟수를 구한다. 단, 배열이 정렬된 상태의 정의가 다르다. 배열이 $1,2,\dots,N$이거나, $2,3,\dots,N,1$이거나, ... 하는 식으로 $1,2,\dots,N$을 cyclic shift한 모든 경우를 정렬이 된 상태라고 정의한다.

가장 나이브한 방법을 생각해보자. 배열이 정렬되었음을 나타내는 상태인 $N$가지 경우 모두에 대해서 E번을 해결할 때 사용한 방법을 사용하면 $O(N^2logN)$에 문제를 해결할 수 있다.

하지만, $N$ 제한이 너무 커서 이러한 방법으로는 문제를 해결할 수 없다. 어떻게 해야 연산 횟수를 줄일 수 있는지 고민해보자. 일단 드는 생각은, $N$가지 경우중 한 가지 경우에 대해 답을 구해놓으면 그걸 이용해서 다른 경우의 답은 빠르게 구할 수 있지 않을까 하는 것이다. 결국 모두 비슷한 로직을 거치는 것이며, 정렬된 상태간의 차이도 한 칸씩 cyclic shift되어있을 뿐이기 때문이다.

따라서, $1,2,\dots,N$으로 정렬하는 경우에 필요한 최소 연산 횟수를 구해놓고, 여기서부터 $2,3,\dots,N,1$으로 정렬하는 경우에 필요한 최소 연산 횟수를 어떻게 하면 빨리 구할 수 있을지 생각해보자.

가장 왼쪽 수가 $x-1$이었다가 $x$가 될 때, 나머지 수들끼리는 대소관계가 바뀌지 않으며 $x-1$이 가장 작은 수에서 가장 큰 수가 되면서 이 수와 다른 수 간의 대소관계만 서로 바뀌게 된다. 또, 이 수는 가장 작은 수에서 가장 큰 수가 되었으므로, $x$의 왼쪽에 있는 수들과는 역위 관계였다가 역위 관계가 아니게 되고, 오른쪽에 있는 수들과는 역위 관계가 아니었다가 역위 관계가 되게 된다.

따라서, 이 변형 과정에서 바뀌는 역위 개수는 ($x$ 왼쪽에 있는 수의 개수)만큼 감소하고, ($x$ 오른쪽에 있는 수의 개수)만큼 증가하게 된다.

즉, 각 수의 위치를 미리 저장해두면 한번만 전체 역위 개수를 저장한 후 맨 왼쪽 수를 한 칸 밀었을 때 역위 개수를 $O(1)$에 계산할 수 있음을 알 수 있다. 역위 개수를 한 번 구하는데 $O(NlogN)$, 각 칸을 밀면서 역위 개수를 갱신하는데 $O(N)$ 시간이 걸리므로 전체 문제를 $O(NlogN)$에 해결할 수 있고 이는 문제를 해결하는데 충분한 시간복잡도다.

## H. Frog Pushers

문제 요약) 그래프가 주어진다. 그래프에서 간선이 주어진 순서대로 맨 처음부터 하나씩 간선을 제거한다. 각 간선을 제거할 때마다 그 그래프의 MST 값을 구해서 출력하라.

가장 나이브한 방법을 생각해보자. 간선을 지울 때마다 다시 MST를 구하면 $O(M(N+MlogM))$ 시간에 문제를 해결할 수 있다.

하지만, $M$ 제한이 너무 커서 이 방법으로는 문제를 해결할 수 없다. 문제를 보면 $M$ 제한이 매우 큰데 $N$제한은 아주 작아서 이를 이용할 여지가 없을까 하는 생각이 든다. 이 제한을 $M$이 아니라 $N$에 바운드 시킬 수 있는 방법이 있을까?

그리고 이미 간선이 엄청 많은 상태에서 간선을 하나씩 지우면서 갱신하는건 문제가 어려워보인다. 반대로, 맨 뒤에서부터 보면서 간선을 하나씩 추가한다고 생각해보면 어떨까. 기존에 MST를 구해놓고, 새로운 간선이 하나 추가됐을 때 그 간선으로 인해 변경되는 MST만 찾는다고 생각하면? MST는 결국 트리이기 때문에 간선 개수도 $N-1$개가 되어서, 트리만 한 번 전체 확인하고 MST를 갱신할 수 있다면 문제를 충분히 빠르게 해결할 수 있을 것 같다.

그러니 기존에 어떤 MST를 이미 구해뒀고, $u$와 $v$를 잇는 $w$ 가중치의 간선이 하나 새로 추가됐다고 생각해보자. 기존에는 트리 구조이기 때문에, 이 간선을 추가하면 $u$와 $v$가 포함된 사이클이 하나 생긴다. 그리고, 새로 추가된 간선이 영향을 끼치는 것도 이 사이클 하나밖에 없다.

새 간선을 추가한다면, 사이클에서 가장 가중치가 큰 간선을 하나 제거하는게 최선이다. 추가하지 않는다면, 기존 MST가 최선이다.

따라서, 기존에 $u$와 $v$를 잇는 경로에서 가장 가중치가 큰 간선을 하나 구해서 이 걸 제거하고 새 간선을 추가하는 과정만 수행해주면 새로운 MST를 구할 수 있다. 이러한 과정은 $O(N)$에 수행할 수 있으므로, 역방향으로 간선을 추가하면서 확인하면 각 단계마다 $O(N)$시간이면 MST를 갱신하는데 충분함을 알 수 있다. 따라서, 전체 문제를 $O(NM)$에 해결가능하고 이는 문제를 해결하기에 충분한 시간복잡도다.
 
