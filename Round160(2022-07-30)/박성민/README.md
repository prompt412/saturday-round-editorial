

<img width="806" alt="image" src="https://user-images.githubusercontent.com/50068946/181909104-96a3c234-0686-4a77-a73d-25798e53d247.png">

D번과 E번을 풀려고 했었다. 이번에는 못 풀었긴 한데 그래도 한 80퍼는 접근하고 틀려서 집 가서 다시 풀어보았다. 

## D번 14615 Defend the CTP!!!

1. bfs로 시도했다 -> 시간초과
2. 한번 확인한 경우는 값을 저장해놓으면 빨라지지 않을까? -> 시간초과
3. cin으로 빠른 입출력을 사용하면? -> 시간초과

 
3진 시간초과로 다음 문제로 넘어갔다. 
사실 cin의 경우는 scanf를 썼지만 혹시나 싶어서 cin + `ios_base::sync_with_stdio(false); cin.tie(NULL);`을 사용했지만 별 차이 없는 것 같았다. 

알고보니!!! 1에서 출발해서 갈 수 있는 곳을 체크하고 x에서 출발해서 n으로 갈 수 있는 곳을 체크한 다음 둘 다 true인 곳을 구하면 된다.
그런데 x에서 출발해서 n으로 갈 수 있는 곳을 체크하는 건 어려우므로 역방향으로 n에서 갈 수 있는 곳을 체크한다(!!!!!!!!!) 이렇게 풀 수 있구나. 

내가 시간초과가 난 이유는 n * (n + m) = 10^5 * (10^5 + 10^6)이어서 시간 초과가 난 것 같다. 
지금 풀이는 bfs 두 번 돌리므로 2 * (n + m)이어서 안 터지는 것 같다. (계산 틀리면 알려주세요)

## E번 24778 Cracking The Safe

아... 어케풀지 고민하다 이전에 비슷한 문제를 푼 기억이 났다. 생각해보니 십자 뒤집기 문제와 비슷했다.
3*3이라 경우가 얼마 없으니 모든 뒤집는 경우를 다 구하면 되겠다 싶었다.

그래서 모든 버튼을 누르는 경우를 구했는데 틀렸다.. 
알고보니 이게 한 번만 누르는게 아니라 0, 1, 2, 3 3번을 누를 수 있어서 3번 누르는 경우를 전부 확인해야 했다. 
그럼 이걸 어떻게 처리할 것인가? 00, 01, 10, 11 두 비트로 사용해볼까 싶었는데 그럼 1 더할 때 캐리 비트를 어떻게 처리할지 고민이었다.. 

결국! 비트는 포기하고 백트래킹으로 풀었다. 코드는 빠르게 짰는데 답이 안 나왔다.. 분명 재귀로 이렇게 짜는게 맞는데...? 여러 번 시도 끝에 풀긴 풀었다. 시도한 것들은 다음과 같다. 

1. 십자로 뒤집어야 하는데 한 칸만 뒤집고 있었음
2. idx가 9까지 가야 모든 칸이 0인지 확인했음
3. 무조건 한 칸에 하나씩 증가시켰음 (증가시키지 않는 경우도 존재)

결국 풀었다!






