
## 감상

A~G까진 잘 푼 것 같은데 H는 마땅히 떠오르는 풀이가 없어서 적당히 끝냈다. 나중에 풀이를 보고 공부해서 풀어야할 것 같다. 저런 유형의 문제에 좀 취약한 것 같기도 하고..

## 타임라인

### 00:02 A WA

대충 슥 읽고 짰는데 모음이 없으면 그냥 문자열 + ay 출력하라는 조건을 빼먹어서 틀렸다.

### 00:03 A AC

해당 부분을 찾아서 고치고 AC. 그 다음으로 B번을 읽었는데, 문제 이해가 잘 안 됐다.  괜히 시간 쓰지 말고 넘어가자는 생각이 들어서 패스하고 C번으로 넘어갔다.

### 00:07 C AC

문제 조건에 따라 구현한 후 AC. 그리고 D번을 읽어봤는데, 구현량이 많고 실수하기 쉬운 구현 문제였다. 당장 이걸 잡았다가 틀리면 말릴 것 같아서 일단 E번으로 넘어갔다.

### 00:16 E AC

읽어보니 몇 번 본 적 있는 유형의 문제여서 빠르게 풀고 AC를 받았다. 그리고 F를 열어봤는데, 그림만 봐도 풀기 짜증날 것 같이 생긴 문제라 다시 BD를 한 번 보고 오자는 생각이 들었다.

### 00:20 B AC

B번을 다시 읽어보니 아까 이해가 안 됐던 부분이 입력 란에 $A_i >= N $ 조건이 있어서 별 상관이 없는 부분이었다. 그래서 처음에 읽고 생각했던 풀이를 짜서 AC를 받았다.

### 00:35 D AC

그리고 다시 G로 넘어가서 문제를 읽어봤는데, F나 G나 쉽게 풀릴 문제는 아닌 것 같아서 이쯤에서 D를 붙잡아야할 것 같은 느낌이었다. 그래서 D를 잡고, 차근차근 구현해서 다행히 한번에 AC를 받았다.

### 00:54 G AC

F랑 G 중에 뭘 풀까 고민하다가, F는 대충 풀이가 나왔는데 비슷하게 구현이 좀 까다로울 것 같았다. 그래서 G번으로 넘어가서 생각하다보니 깔끔한 풀이가 나와서 G를 먼저 풀었다.

### 01:16 F TLE

다음으로 F를 붙잡고 생각한 풀이의 구현을 시도. 시간 초과날 부분이 없는 것 같은데 이상하게 TLE가 났다.

### 01:19 F TLE

그래서 혹시나 해서 $logN$ 만큼 더 시간이 걸리던 부분을 떼고 다시 재출해봤으나, 여전히 TLE.

### 01:19 F AC

다시 코드를 보니 N, M을 잘못 쓴 부분이 있었다.. 입력에서 TLE가 나고 있었던 상황. 고쳐서 AC를 받았다.

### 01:40 ~

그 다음은 H를 붙잡고 열심히 풀이를 고민해봤는데 마땅한 방법이 생각이 안 났다. 그래서 적당히 치우고 후기를 정리했다. 나중에 풀이를 보고 공부해볼 예정.

## 풀이

### A. 도깨비말

모음이 처음으로 나오는 위치를 찾아서 문자열을 그 위치부터 시작하게 회전시킨 후 맨 마지막에 ay를 붙여서 출력하면 된다.

### B. 불꽃놀이

결국 맨 왼쪽 끝 더미와 오른쪽 끝 더미가 마지막에 남게 되기 때문에, 이 둘을 최대한 감소시켜야 한다.

둘 중 더 큰 쪽을 1씩 계속 줄이다가, 마지막 남은 하나의 더미는 양쪽을 모두 1만큼 감소시키므로 이 처리를 해서 풀어주면 문제를 해결할 수 있다.

### C. 스텔라(STELLA)가 치킨을 선물했어요

문제에서 주어진 정렬 조건에 따라 전체 정렬을 시킨 후, 6등부터 $N$등까지 사람들에 대해 5등과 같은 문제 푼 수를 가진 사람의 수를 세서 출력해주면 된다.

### D. 관리 난항

문제 지문에 적힌 내용을 충실히 구현하면 된다. 근데 그게 어렵다..

### E. Twitch Plays VIIIbit Explorer

이동 횟수는 중요하지 않으므로, 최대 업그레이드를 할 수 있는 방법만 찾아주면 문제를 해결할 수 있다. 가능한 최대 업그레이드 횟수는 (S에 포함된 문자 C 개수) / (존재하는 문자 C 개수) 중 최솟값과 같으므로, 이 횟수를 채우는 이동 방법만 찾아주면 된다.

이는 각 문자마다 그 문자가 있는 위치를 모아놓고, 각 위치를 그냥 S 문자열에 포함된 순서대로 번갈아 방문해주는 걸 최대 업그레이드 횟수만큼 반복하면 된다. 큐 같은 형태로 관리해주면 각 문자가 있는 남은 위치 목록도 어렵지 않게 관리할 수 있다.

### F. Rectilinear Regions

각 path가 꺾이는 지점들을 모아서 x축으로 정렬한 후 순서대로 계산한다고 생각해보자. L과 U의 위아래가 서로 바뀔 때, 유지할 때 등으로 조건을 나눠놓고 생각해보면 생각보다 식이 깔끔하게 도출된다.

### G. Circular DNA

각 type 별 gene만 모아놓고 생각했을 때, 올바른 괄호쌍 문제를 해결하는 형태가 된다. 여는 괄호를 $s_i = 1$, 닫는 괄호를 $e_i = -1$ 이라고 할 경우 전체 합이 $0$이며 최솟값도 $0$이어야 올바른 괄호쌍이 된다.

맨 첫번째 위치를 기준으로 이 값들을 계산해주고 나면 자르는 위치를 바꿀 때마다 맨 앞 원소가 맨 뒤로 가기 때문에 최솟값 변화를 $O(1)$에 구해줄 수 있다. 이 각각의 변화에 대해 최솟값이 올바른 괄호쌍을 구성할 수 있는 케이스를 모두 구해주는 식으로 문제를 $O(N)$ 시간에 해결할 수 있다.

### H. 울타리

풀고 업데이트할 예정.
