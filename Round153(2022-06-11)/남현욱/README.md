
## 감상

이번 주는 그냥 저냥 무난하게 풀었던 것 같다. 막판에 div1 EF 에서 약간 잘 못한 것 같아서 아쉬운데, 그냥 실력대로 한 것 같은 느낌. F를 시간복잡도가 될지 고민하다가 시간을 너무 많이 쓴게 제일 큰 문제였다. 애매해보이는 시간복잡도 + 상수가 적음 풀이가 생각날 경우 그냥 한 번 시도해보는 습관을 들여야할 것 같다. 매번 이런 경우에 시간 낭비하다 망하는 듯.

## Timeline

처음 시작하고, A를 읽어본 다음에 잘 이해도 안 되고 대충 보기에 풀기 까다로워보여서 적당히 치우고 B로 이동했다.

### 00:06 B AC

B번은 유명한 DP 문제인 maximum subarry를 그대로 옮겨온 문제여서 그 풀이를 그대로 구현후 AC.

### 00:11 C AC

$O(N^3)$ 풀이가 빠르게 생각나서 그걸 구현하고 AC를 받았다.

그리고 D,E를 읽어봤는데, 둘 다 꽤 까다로워보였다. D번은 풀이를 조금 고민해봤지만 쉽지 않아보여서, 일단 이 시점에서 A를 풀어야겠다고 판단했다.

### 00:23 A AC

A를 다시 읽어보니 풀이는 금방 생각났는데, 구현이 좀 짜증났다. 중간에 살짝 헤맨 후 AC.

### 00:40 D AC

다시 D를 보고 몇가지로 케이스 분류를 해보니 풀 수 있겠다는 생각이 들었다. 그 풀이를 구현 후 AC.

### 00:55 E WA

구현 후 제출을 했는데 WA가 나왔다. 몇 가지 케이스를 넣어보니 풀이 생각했던 거에서 몇 가지 과정을 빼먹었다는 걸 깨닫고 그걸 고쳐서 다시 제출.

### 01:00 E WA

하지만 또 WA.. 다시 보니 $ f(1) = 1 $인 케이스를 제대로 처리하지 못하고 있다는 걸 깨닫고 고쳐서 제출했다.

### 01:02 E 6점

다시 제출해보니 이번엔 6점이 나왔다. 첫번째 서브태스크만 맞고 나머지는 다 틀리는게 이상해서 문제를 다시 읽어보니, $m$ 제한이 $10^9$인데 이걸 $n$이랑 같은 제한으로 생각하고 풀었다는 걸 깨달았다. 그래서 그 부분을 고쳐서 다시 제출.

### 01:03 E 6점

그런데 또 6점.. 또 어딘가 $m$ 제한 관련해서 실수를 했을 것 같아서 코드를 슥 보니까 $ \infty $ 상수값을 $m$ 최대 제한보다 작게 잡았었다는 걸 깨닫고 이걸 고쳐서 제출.

### 01:04 E AC

그리고 결국 AC. 사소한 몇 가지 실수들을 제대로 캐치하지 못해서 너무 패널티를 많이 쌓은 것 같아 그 부분이 아쉬웠다.

F를 읽어보니 몇 가지 풀이가 생각나긴 했는데, 전부 시간복잡도상 너무 빡빡하지 않나 싶었다. 어쨌건 $O(logN)$ 정도가 안 들어갈 수 없는데 이게 붙으면 통과할 수가 없어 보여서.. 그래서 선형 풀이가 되는지 좀 고민해보다가 아무래도 선형은 안 되는 거 같아서 그냥 로그가 붙은 풀이를 짜서 제출해봤다.

### 01:30 F TLE

하지만 당연하게도 TLE.. 구현이 귀찮아서 심플하게 set을 쓰는 구현을 냈는데 이게 문제인 거 같아서 좀 더 가볍게 uf를 쓰는 풀이로 선회했다.

### 01:56 F TLE

겨우 고쳐서 제출했는데, 또 TLE. 하지만 이전보단 좀 더 진행이 됐다. 시간이 너무 없어서 여기서 몇 가지 상수 최적화라도 더 해보자 생각하고 vector를 for문마다 다시 잡는걸 외부 전역 배열로 빼고 memset을 쓰는식으로 고쳐서 내봤다.

### 01:57 F TLE

하지만 또 TLE. 나머지 시간 동안 고치지 못하고 그대로 연습 종료.

연습이 끝나고 다시 확인해보니 로직을 좀 잘 못 짠 부분이 있었다. merge를 하는 과정이 이상해서 최악의 경우 $O(N^3)$이 될 수 있었다. 좀 더 침착하게 했으면 F도 풀었을 것 같은데 살짝 아쉬운 기분.

## 풀이

### Div1 A. HAN

각 문자가 나온 횟수를 $cnt$ 배열에 저장한다고 생각하고, 내가 마지막으로 부른 알파벳이 $x$, 부를 방향을 $d$, 지금까지 계산한 부른 횟수를 $p$ 라고 하자. $p = n$이 될 때까지 순서대로 시뮬레이션하는게 가장 나이브한 풀이 방법이다. 이 경우, $O(NQ)$ 시간에 문제를 해결할 수 있지만 $N$이 너무 커서 이 방법으로는 TLE를 받게 된다.

여기서 관찰할 수 있는 사실 중 하나는 쿼리로 주어진 $n$ 에 대해 $ 26 \le n - p$ 인 경우, 일일히 시뮬레이션 하지 않고도 모든 알파벳을 다 한 번씩 추가로 불렀다 치고 $p + 26$번 위치로 이동할 수 있다는 것이다. 이와 같은 논리를 임의의 26의 배수 단위에 대해서도 적용할 수 있으므로, 이를 이용해 $n - p$ 차이가 26이상일 경우 한 번에 가능한 한 큰 26의 배수만큼 이동해주고 나머지 짜투리만 시뮬레이션 하는 방식으로 최적화하면 문제를 $O(Q)$에 해결할 수 있다. 방향을 전환하는 경우도 마찬가지 방식으로 $p=n$이 될때까지 시뮬레이션 해 준후 $d$ 값만 $-d$로 갱신해주면 된다.

### Div1 B. 수익

maximum subarray problem이라는 이름으로 알려진 유명한 DP 문제이다. $ DP(i) $ 를 어떤 $p \le i $ 인 $p$에 대해 $p \dots i$ 구간을 골라서 얻을 수 있는 최대 수익이라고 정의하자.

이 경우 $ DP(i) = max(DP(i-1) + a_i, a_i) $ 가 성립한다. $i-1$일까지 연속한 수익에 $a_i$를 덧붙이는 경우가 내 앞의 원소까지 고르는 경우의 최선이고, 그 경우를 빼면 $i$번째 값 하나만 선택하는 경우만 남기 때문이다.

따라서 이 방식대로 구한후 $DP(1), DP(2), \dots, DP(N)$ 중에 제일 큰 값이 답이므로 이 값을 출력해주면 문제를 해결할 수 있다.

### Div1 C. 토너먼트 만들기

DP 풀이가 있고 그리디 풀이가 있다.

DP로 푸는 경우, $DP(l, r)$을 $l$번째 부터 $r$번째 참가자를 이용해서 토너먼트를 만들 때 랭킹 차이 총합 최소라고 정의하자. 우리가 구하고자 하는 답은 $DP(0, N-1)$이 된다.

이 때, 전체 토너먼트의 결승전을 기준으로 생각해보면, 어떤 $l \le m \lt r$인 $m$을 하나 골라서, $l \dots m$까지 참가자로 토너먼트를 하나 만들고 $m+1 \dots r$까지 참가자로 토너먼트를 하나 만들어서 양쪽에서 승자를 구해 둘이 붙는게 결승전이 될 것이다.

이 모든 경우를 확인해보고 그 중 합이 가장 작은게 $DP(l,r)$의 답이 될 것이므로, $l \dots r$ 사이의 모든 $m$에 대해 $DP(l, m) + DP(m+1,r) + \mid min_{x=l \dots m}(a_x) - min_{y=m+1 \dots r}(a_y) \mid $ 를 구해보면 $DP(l,r)$의 값도 결정할 수 있다. 따라서 전체 과정을 $O(N^3)$에 해결할 수 있다.

그리디하게 푸는 경우, 전체 배열에서 랭킹 값이 가장 큰 참가자의 위치를 찾고 이 참가자를 그 참가자의 왼쪽 혹은 오른쪽 중 하나와 경기시키는 걸 반복해주는 식으로 풀 수 있다. 경기를 시킬 때는 항상 해당 참가자와 랭킹 값이 가장 가까운 원소와 매칭시켜준다.

증명)

현재 배열에서 값이 가장 큰 참가자의 위치를 $p$라고 하자. 이 참가자는 반드시 해당 경기를 한 후 탈락하게 된다(값이 가장 크므로). 이 때 이 참가자는 $p-1$번 참가자 혹은 $p+1$번 참가자 둘 중 하나와 경기를 시켜야하는데, 두 경우를 각각 생각해보자.

- $p-1$번 참가자와 경기하는 경우 : $p$번 참가자가 탈락하고, 나머지 참가자들은 $1, 2, \dots p-1, p+1, \dots, n$이 순서대로 남게 된다.
- $p+1$번 참가자와 경기하는 경우 : $p$번 참가자가 탈락하고, 나머지 참가자들은 $1, 2, \dots p-1, p+1, \dots, n$이 순서대로 남게 된다.

따라서, $p$번 참가자가 누구와 경기하든 상관없이 해당 참가자가 탈락한 후 생존한 토너먼트에 참가자 구성은 일치한다. 그러므로, $p$번 참가자를 최대한 랭킹 값 차이가 적은 참가자와 경기를 시키는게 항상 이득이므로 해당 그리디 전략은 성립하게 된다. 구현에 따라 $O(NlogN)$ 에서 $O(N^2)$ 정도 시간복잡도에 문제를 해결할 수 있다.

### Div1 D. INU 막대기

먼저, II, NN, UU 막대기들은 자신들끼리 연결해서 전부 연결하는게 가능하다. 이렇게 한 종류만 써서 만들 수 있는 최대치를 일단 답으로 고려해보자.

다음으로, IN, NU, IU 막대기들을 쓰는 경우를 생각해보자.

- IN을 쓰는 경우 : (II II II ... II) (IN NI IN ... NI IN) (NN NN NN ... NN) 꼴로 연결할 수 있다. 이 때 IN 개수가 짝수개면 나머지 한 개의 IN은 NN 끝에 붙이든 II 끝에 붙이든 할 수 있다. 따라서, 이 경우는 (IN 길이 합) + (NN 길이 합) + (II 길이 합)이 된다. NU, IU 에 대해서도 마찬가지 논리를 적용할 수 있다.

- IN, IU를 쓰는 경우 : (UU UU UU ... UU) (UI IU UI ... IU UI) (II II II ... II) (IN NI IN ... NI IN) (NN NN NN ... NN) 꼴로 연결할 수 있다. 마찬가지로 IN, IU중에 짝수개인게 있어서 짜투리가 남는 경우 IU는 UU쪽 끝에, IN은 NN쪽 끝에 붙여줄 수 있으므로 항상 전부 다 사용할 수 있다. IN, NU를 쓰는 경우, IU, NU를 쓰는 경우에 대해서도 마찬가지 논리를 적용할 수 있다.

따라서 이 모든 경우를 고려해주면 문제의 답을 구할 수 있다.

### Div1 E. 합성함수와 쿼리 2

$ g_b(x) $ 를 $f^{2^b}(x)$ 라고 정의하자. $g_b(x)$ 값을 전처리해두면, $m \lt 2^{b+1} $인 $m$ 에 대해 $f_m(x)$ 값을 구할 수 있음이 알려져 있다(binary lifting 혹은 sparse table 이라는 명칭으로).

문제는 여기서 쿼리로 $f(1)$의 값이 바뀔 수 있다는 건데, 이를 감안하여 1을 거쳐가는 경우는 빼고 전처리한다고 생각해보자. 즉, $f(x) = 1$ 인 경우 $f(x)$가 존재하지 않는 걸로 생각하고 끊어버린 다음 각각의 $x$에 대해 $g_b(x)$를 전처리해두는 것이다. 이렇게 전처리해두면 $f^d(x) = 1$을 만족하는 $d$를 $O(logM)$ 시간에 구할 수 있다.

이제 각각의 케이스를 생각해보자.

- $1$이 아닌 어떤 수 $x$에서 시작하는 경우 : 일단, $x$가 1이 되려면 $f$를 몇 번 적용해야하는지 구한다. 이 횟수가 $m$보다 크다면 그냥 그 위치까지 이동해서 출력하면 되고, 그렇지 않다면 일단 해당 횟수만큼 적용해서 $1$로 이동했다고 친다. 그러면 아래의 $1$로 시작하는 케이스로 환원되므로 아래 케이스를 해결함으로서 문제를 풀 수 있다.
- $1$에서 시작하는 경우 : $f(1) = k$ 라고 하자. $k$에서 시작해서 다시 1이 되려면 $f$를 몇 번 적용해야하는지 구한다. 이 횟수를 $t$라고 했을 때, $t+1$번 간격으로 다시 $1$로 돌아오는 싸이클이 형성됨을 알 수 있다. 따라서 $m을 $t+1$로 나눈 나머지를 기준으로 문제를 풀 수 있다. 이렇게 하고 나면 다시 위 케이스에서 한 것과 마찬가지 방식으로 $O(logM)$에 원하는 값을 구할 수 있다.

따라서, $O((N+Q)logM)$ 시간에 문제를 해결할 수 있다.

### Div1 F. 포스터

우선 전체 좌표를 압축해서 최대 10000x10000 필드를 구성한다. 이제 각 사각형을 차지하는 포스터가 뭔지를 결정해주면 되는데, $x=1 \dots 10000$ 까지 순회하면서, 각각의 $y$에 대해 최대한 포스터 번호가 높은 것부터 순서대로 칠할 것이다. 이 때 이미 칠해진 칸만 적절히 빠르게 건너뛰는 처리가 필요하고, 이러한 처리는 union-find를 응용해서 구현할 수 있다. 이 로직을 충실히 구현해주면 $O(N^2logN)$에 문제를 해결할 수 있다. 시간 제한이 빡빡해서 최대한 연산을 가볍게 해줄 필요가 있다.
