
## 풀이

### A. 고고학자 예린

코드를 그대로 옮기면 TLE가 나기 때문에.. 루프를 잘 정리해서 수식으로 만들어주어야한다.

안쪽의 j,k 루프를 합치면 $(a+b) \cdot (a+b-1)/2$ 가 되고,

바깥의 i루프는 이 과정을 $a+b$ 번 반복하므로,

$(a+b)^2 \cdot (a+b-1)/2$를 출력해주면 문제가 해결된다.

### B. 제리와 톰 2

맨 끝에서부터 분수 연산을 반복해주면 해결할 수 있다. 분수의 분모와 분자를 관리하며 $a_i$를 더하고 뒤집는걸 반복해준다. 물론 중간중간 과정에서 기약 분수 꼴은 유지해주어야 한다.

### C. 소수 최소 공배수

에라토스테네스의 체를 이용해서 수열에 속한 원소중 소수만 빠르게 골라내고, 그 수들 전체의 최소 공배수를 구해서 출력하면 된다.

### D. 꿈틀꿈틀 호석 애벌레 - 기능성

결국, 각 위치에서 할 수 있는 선택은 1. 포기한다, 2. 만족도 $K$ 이상이 될 때까지 연속한 구간을 먹는다 두 가지로 정리할 수 있다.

$DP(i)$를 $i$번째부터 $n$번째까지 구간에 대해 얻을 수 있는 탈피 에너지 최댓값 이라고 정의하자.

이때, $end_i$를 $i$번째부터 순서대로 더해서 합이 $K$이상이 되는 최초 위치라고 정의하자. 이러면,
$DP(i) = max(DP(i+1), DP(end_i+1) + sum(arr_i \dots arr_{end_i}) - K) $로 정의할 수 있다.

$end_i$ 위치를 순회하면서 찾아주면 $O(N^2)$에 문제를 해결할 수 있고, 이분 탐색 혹은 투 포인터를 이용하여 빠르게 찾아주면 $O(NlogN)$ 혹은 $O(N)$에 해결할 수 있다. 빠른 풀이로 20168번(효율성)을 해결 가능.

### E. 종이에 숫자 쓰기

주어진 소수를 분수 꼴로 나타내고 생각해보자. 종이를 한장 쓸 때마다 분모가 1증가, 분자가 종이에 써 있는 숫자만큼 증가한다고 생각할 수 있다. 이 때, 분모 크기가 가장 작은 건 분수를 기약 분수 꼴로 나타냈을 때이므로, 기약 분수 형태로 만들어놓고 주어진 장수 만큼을 이용해서 분자 값을 구성하면 문제를 해결할 수 있음을 알 수 있다.

분모가 $u$이고 분자가 $d$일 때 카드 $i$를 사용 가능한 최대 횟수 $cnt$는 $u - i \cdot cnt \ge d - cnt$를 만족해야 하므로, 이 식으로부터 각 카드의 장수가 몇장인지를 구할 수 있다. 5부터 시작해서 4,3,2,1 순서로 쓸 수 있는 한 최대한 많은 카드를 쓰는 걸 반복하면 해결 가능.

### F. 달력 놀이

달력을 건너뛰는 규칙을 잘 맞춰서 게임 DP를 구현하면 해결이 가능하다. 구현이 좀 까다로운 문제.

### G. 모독

$cnt_i$ 를 배열에 $i$가 존재하는 개수라고 하자.

이 문제는 결국 $cnt_i = 0$을 만족하는 가장 작은 $i$를 찾고,

$x \le i $를 만족하는 $x$에 대해 $cnt_x$의 합을 구하는 쿼리를 구현하는 문제가 된다.

이는 세그먼트 트리를 조금 응용해서 구현할 수 있다. 세그먼트 트리의 각 노드가 $idx, sum$ 두 개 원소로 구성된다고 생각하자. $idx$는 노드가 담당하는 구간에서 $cnt_i=0$을 만족하는 가장 작은 $i$, $sum$은 담당 구간에서 $idx$ 왼쪽 위치의 $cnt_i$값 합을 나타낸다. 이렇게 생각하면 두 노드를 합치는 과정은 어렵지 않게 생각할 수 있고, 따라서 전체 문제를 $O(K + QlogK)$에 해결할 수 있다.

### H. 복붙하기

Suffix Array를 이용하여 문제를 해결할 수 있다. 주어진 문자열에서 SA와 LCP를 구하고 생각해보자.

먼저, 인접한 두 SA $x, y (x \lt y)$ 와 두 SA의 LCP값 $k$에 대해, 다음 두 가지 경우를 고려한다.

1. $k \le y - x$ . 이 경우, 최대한 선택할 만큼 선택해도 두 접미사에서 중복되는 부분이 없으므로 가능한 최대치는 $k$가 된다.
2. 그 외의 경우. 이 경우, 최대한 선택하면 문자열에서 겹치는 부분이 생겨서 문제의 조건을 만족시킬 수 없다. 이 때, 겹치는 경우 $k$ 크기 간격으로 똑같은 문자열이 반복된다는 성질을 이용한다. 겹치는걸 포함해서 가능한 전체 문자열은 $k + y - x$ 길이이며, 이 문자열은 구간 $k$ 간격으로 동일한 문자열이 반복된다. 여기서 겹치지 않으면서 최대한 긴 부분 문자열을 선택하려면, 이 문자열을 $k$ 단위 구간으로 나눠서 중간보다 뒤쪽의 제일 앞 위치를 선택하면 된다.

따라서 Suffix Array를 구축하고 나면 문제를 $O(N)$에 해결할 수 있으므로, SA 구현체에 따라 전체 문제를 $O(Nlog^2N)$ 혹은 $O(NlogN)$ 시간에 해결할 수 있다.
